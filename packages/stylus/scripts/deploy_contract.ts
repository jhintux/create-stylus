import { spawn } from "child_process";
import { config as dotenvConfig } from "dotenv";
import prettier from "prettier";
import * as path from "path";
import * as fs from "fs";
import { ethers } from "ethers";
import { arbitrumNitro } from "../../nextjs/utils/scaffold-eth/chain";

// Load environment variables from .env file
const envPath = path.resolve(__dirname, "../.env");
if (fs.existsSync(envPath)) {
  dotenvConfig({ path: envPath });
}

interface DeploymentConfig {
  endpoint: string;
  privateKey: string;
  contractName: string;
  deploymentDir: string;
  contractAddress?: string;
}

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

function getDeploymentConfig(): DeploymentConfig {
  return {
    endpoint: process.env["ENDPOINT"] || "http://localhost:8547",
    privateKey: process.env["PRIVATE_KEY"] || "0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659",
    contractName: process.env["CONTRACT_NAME"] || "stylus-hello-world",
    deploymentDir: process.env["DEPLOYMENT_DIR"] || "./deployments",
  };
}

function ensureDeploymentDirectory(deploymentDir: string): void {
  const fullPath = path.resolve(__dirname, "..", deploymentDir);
  if (!fs.existsSync(fullPath)) {
    console.log(`üìÅ Creating deployment directory: ${fullPath}`);
    fs.mkdirSync(fullPath, { recursive: true });
  }
}

function executeCommand(command: string, cwd: string, description: string): Promise<string> {
  console.log(`\nüîÑ ${description}...`);
  console.log(`Executing: ${command}`);

  return new Promise((resolve, reject) => {
    const childProcess = spawn(command, [], {
      cwd,
      shell: true,
      stdio: ['inherit', 'pipe', 'pipe']
    });

    let output = '';
    let errorOutput = '';

    // Handle stdout
    if (childProcess.stdout) {
      childProcess.stdout.on('data', (data: Buffer) => {
        const chunk = data.toString();
        output += chunk;
        process.stdout.write(chunk); // Print live output
      });
    }

    // Handle stderr
    if (childProcess.stderr) {
      childProcess.stderr.on('data', (data: Buffer) => {
        const chunk = data.toString();
        errorOutput += chunk;
        process.stderr.write(chunk); // Print live error output
      });
    }

    // Handle process completion
    childProcess.on('close', (code: number | null) => {
      if (code === 0) {
        console.log(`\n‚úÖ ${description} completed successfully!`);
        resolve(output);
      } else {
        console.error(`\n‚ùå ${description} failed with exit code ${code}`);
        reject(new Error(`Command failed with exit code ${code}. Error output: ${errorOutput}`));
      }
    });

    // Handle process errors
    childProcess.on('error', (error: Error) => {
      console.error(`\n‚ùå ${description} failed:`, error);
      reject(error);
    });
  });
}

async function generateTsAbi(abiFilePath: string, contractName: string, contractAddress: string) {
  const TARGET_DIR = "../nextjs/contracts/";
  const abiTxt = fs.readFileSync(abiFilePath, "utf8");
  
  // Extract from 4th row to the end
  const lines = abiTxt.split('\n');
  const extractedAbi = lines.slice(3).join('\n');

  const fileContent = `${arbitrumNitro.id}:{"${contractName}":{address:"${contractAddress}",abi:${extractedAbi}}}`;

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }

  fs.writeFileSync(
    `${TARGET_DIR}deployedContracts.ts`,
    await prettier.format(
      `${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract"; \n\n
 const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`,
      {
        parser: "typescript",
      },
    ),
  );

  console.log(`üìù Updated TypeScript contract definition file on ${TARGET_DIR}deployedContracts.ts`);
}

function generateContractAddress(): string {
  // Generate a random private key and derive the address
  const wallet = ethers.Wallet.createRandom();
  return wallet.address;
}

export default async function deployStylusContract() {
  console.log("üöÄ Starting Stylus contract deployment...");

  const config = getDeploymentConfig();

  // Generate contract address
  config.contractAddress = generateContractAddress();
  console.log(`üìã Generated contract address: ${config.contractAddress}`);

  console.log(`üì° Using endpoint: ${config.endpoint}`);
  console.log(`üîë Using private key: ${config.privateKey.substring(0, 10)}...`);
  console.log(`üìÑ Contract name: ${config.contractName}`);
  console.log(`üìÅ Deployment directory: ${config.deploymentDir}`);

  try {
    // Ensure deployment directory exists
    ensureDeploymentDirectory(config.deploymentDir);

    // Step 1: Deploy the contract using cargo stylus with contract address
    const deployCommand = `cargo stylus deploy --endpoint='${config.endpoint}' --private-key='${config.privateKey}' --contract-address='${config.contractAddress}' --no-verify`;
    await executeCommand(
      deployCommand,
      path.resolve(__dirname, ".."),
      "Deploying contract with cargo stylus",
    );

    console.log(`üìã Contract deployed at address: ${config.contractAddress}`);

    // Step 2: Export ABI
    const exportCommand = `cargo stylus export-abi --output='${config.deploymentDir}/${config.contractName}.txt' --json`;
    await executeCommand(exportCommand, path.resolve(__dirname, ".."), "Exporting ABI");

    console.log("\nüéâ Deployment completed successfully!");
    console.log(`üìÑ ABI file location: ${config.deploymentDir}/${config.contractName}.txt`);

    // Verify the ABI file was created
    const abiFilePath = path.resolve(__dirname, "..", config.deploymentDir, `${config.contractName}.txt`);
    if (fs.existsSync(abiFilePath)) {
      console.log(`‚úÖ ABI file verified at: ${abiFilePath}`);
    } else {
      console.warn(`‚ö†Ô∏è  ABI file not found at expected location: ${abiFilePath}`);
    }

    // Step 3: Generate Ts ABI
    await generateTsAbi(abiFilePath, config.contractName, config.contractAddress);

  } catch (error) {
    console.error("‚ùå Deployment failed:", error);
    process.exit(1);
  }
}

// Allow running this file directly
if (require.main === module) {
  // generateTsAbi(path.resolve(__dirname, "..", "deployments", "stylus-hello-world.txt"), "stylus-hello-world", "0x525c2aba45f66987217323e8a05ea400c65d06dc");

  deployStylusContract().catch(error => {
    console.error("Fatal error:", error);
    process.exit(1);
  });
}
